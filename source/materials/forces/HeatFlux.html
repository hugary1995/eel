<!DOCTYPE html><head><meta charset="UTF-8"><title>HeatFlux | Eel</title><link href="../../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Eel</a><a href="https://github.com/hugary1995/eel" class="right"><img src="../../../media/framework/github-logo.png" class="github-mark"></img><img src="../../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../../eel.html">Documentation</a></li></ul><a href="#" class="sidenav-trigger" data-target="e14467db-b9a6-48ec-8368-211a0f20eead"><i class="material-icons">menu</i></a><ul class="sidenav" id="e14467db-b9a6-48ec-8368-211a0f20eead"><li><a href="../../../eel.html">Documentation</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href="../.." class="breadcrumb">source</a><span class="breadcrumb">materials</span><span class="breadcrumb">forces</span><a href="#" class="breadcrumb">HeatFlux</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="0e95044f-38a0-46db-ae46-e082de2e9a2e" data-section-level="1" data-section-text="HeatFlux"><h1 id="heatflux">HeatFlux</h1><div class="card moose-alert moose-alert-construction"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">build</i><span class="moose-alert-title-brand">construction:</span>Undocumented Class</div><div class="card-content"><div class="moose-alert-content"><p>The HeatFlux has not been documented. The content listed below should be used as a starting point for documenting the class, which includes the typical automatic documentation associated with a MooseObject; however, what is contained is ultimately determined by what is necessary to make the documentation clear for users.</p></div></div></div><p>This class computes the heat flux associated with given energy densities for a given species.</p><section class="scrollspy" id="40952c63-7002-4707-803e-2c2d5c9d5f93" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p></p></section><section class="scrollspy" id="2020a856-a6fe-4c73-8caa-859a889c620a" data-section-level="2" data-section-text="Example Input File Syntax"><h2 id="example-input-file-syntax">Example Input File Syntax</h2><p></p></section><section class="scrollspy" id="520b0031-69f8-4456-90f5-e4e6ed3f69fe" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="903065e1-5efd-4c10-8fe1-56d4aa4b2cce" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">energy_densities</span><span class="moose-parameter-header-description">Vector of energy densities</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;MaterialPropertyName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Vector of energy densities</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">heat_flux</span><span class="moose-parameter-header-description">Name of the heat flux</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Name of the heat flux</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">temperature</span><span class="moose-parameter-header-description">The temperature variable</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>VariableName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The temperature variable</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="0accc5bd-841a-4165-8376-657e63dd45d5" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">block</span><span class="moose-parameter-header-description">The list of blocks (ids or names) that this object will be applied</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of blocks (ids or names) that this object will be applied</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">boundary</span><span class="moose-parameter-header-description">The list of boundaries (ids or names) from the mesh where this object applies</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;BoundaryName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of boundaries (ids or names) from the mesh where this object applies</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">compute</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When false, MOOSE will not call compute methods on this material. The user must call computeProperties() after retrieving the MaterialBase via MaterialBasePropertyInterface::getMaterialBase(). Non-computed MaterialBases are not sorted for dependencies.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">constant_on</span><span class="moose-parameter-header-default">NONE</span><span class="moose-parameter-header-description">When ELEMENT, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps.When SUBDOMAIN, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps. Evaluations on element qps will be skipped</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>NONE</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>NONE, ELEMENT, SUBDOMAIN</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>When ELEMENT, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps.When SUBDOMAIN, MOOSE will only call computeQpProperties() for the 0th quadrature point, and then copy that value to the other qps. Evaluations on element qps will be skipped</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">declare_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any declared properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any declared properties. The suffix will be prepended with a '_' character.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">prop_getter_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="83c558ce-508b-4e95-80c1-32100ca891a6" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>Yes</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">implicit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Determines whether this object is calculated using an implicit or explicit form</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Determines whether this object is calculated using an implicit or explicit form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">seed</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The seed for the master random number generator</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The seed for the master random number generator</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="50bb3e7a-40f5-4659-96a8-62583ba33b79" data-section-level="3" data-section-text="Outputs Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">output_properties</span><span class="moose-parameter-header-description">List of material properties, from this material, to output (outputs must also be defined to an output type)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>List of material properties, from this material, to output (outputs must also be defined to an output type)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">outputs</span><span class="moose-parameter-header-default">none </span><span class="moose-parameter-header-description">Vector of output names where you would like to restrict the output of variables(s) associated with this object</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>none </p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;OutputName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Vector of output names where you would like to restrict the output of variables(s) associated with this object</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Outputs Parameters</h3></summary></details></section></section><section class="scrollspy" id="0546137b-4775-45ea-8d7d-310bbd6626d0" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a class="moose-source-filename tooltipped modal-trigger" href="#93df2b55-6e30-4368-9e07-eafacdd1e3ef">(examples/PCM-GF/equilibriate.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#ef7b5a34-74d3-44a4-a8e1-1fdac9adc621">(examples/LiB/CC_discharging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#715d7aba-fbd5-4f3e-b36c-6e287ad7390b">(examples/SSB/charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#37279865-30f5-4f3b-9fa7-1d2e45243ccb">(examples/SSB/CC_charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#600f29f0-710c-4131-a82c-fd5b9e74792b">(examples/SSB_3D/charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#bcd431d5-36b6-460b-bd4b-777fe378cbdb">(examples/PCM-GF/discharging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#d0d6e79c-9145-40b7-a260-3eb6c860cbb6">(examples/PCM-GF/charging_idling.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#c124c05a-f4eb-4ed0-b545-2a1b35db3c00">(examples/SSB_3D/CC_charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#3a4fe352-db24-42ff-b3bd-243a7ce0cd5c">(examples/SSB/CV_charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#b4c3ba2d-5196-437c-aea6-8ccba5e4787e">(examples/SSB_3D/CC_discharging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#63effe3e-b791-4e5e-ab51-d22dfc38271a">(examples/cable/cable.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#9ef50c8f-bf80-4d0d-8b47-ac9be74e455e">(test/tests/chemical-electrical-thermal/thermal_effects.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#ee901013-7c10-4290-a8df-52435d444b04">(examples/SSB_3D/CV_charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#4e196f5a-8941-4faf-9756-107d41afb371">(test/tests/chemical-electrical-thermal-mechanical/pressure.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#f3a3bb8c-c2f8-4f86-82b5-93fe3cfc9af9">(examples/SSB/CC_discharging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#66eb3869-797e-4b7c-aaf0-80e2905bc400">(examples/LiB/CV_charging.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#21a00a61-23e1-4101-a9a5-504d749fc3ce">(test/tests/electrical-thermal/jh.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#970b64fe-5134-473d-acdd-2426841a6b63">(examples/LiB/CC_charging.i)</a></li></ul></section></section><div class="moose-modal modal" id="93df2b55-6e30-4368-9e07-eafacdd1e3ef"><div class="modal-content"><h4>(examples/PCM-GF/equilibriate.i)</h4><pre class="moose-pre"><code class="language-text"># units are in meter kelvin second (m,kg,s)

end_time = 36000

dtmax = 100
dt = 1

sigma_PCM = 5 # (from Wen&#x27;s measurement of Gfoam+PCM in radial direction) (from Cfoam 70% dense foam = 28571.43) S/m (1/electrical resistivity (0.000035 ohm-m))
kappa_PCM = 10 #18.8 # (average of Kxy = 14 W/m-K, Kz = 23.6 W/mK at T=700C) #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
rho_PCM = 2050 # kg/m^3 #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
cp_PCM = 1074 # J/kg-K #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)

sigma_pipe = 750750.75 # S/m (resistivity 1.332e-6 ohm-m at T = 700C) #Special metal data sheet
kappa_pipe = 23.9 # W/m-K (at 700C) #Special metal datasheet
rho_pipe = 8359.33 #kg/m^3
cp_pipe = 419 # J/kg-K

sigma_gas = 1e-12
kappa_gas = 0.03 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
rho_gas = 1.29 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
cp_gas = 1000 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf

[GlobalParams]
  energy_densities = &#x27;E H&#x27;
[]

[Mesh]
  [fmg]
    type = FileMeshGenerator
    file = &#x27;gold/partial.msh&#x27;
  []
  coord_type = RZ
[]

[Variables]
  [Phi]
  []
  [T]
    initial_condition = 900
  []
[]

[AuxVariables]
  [T_old]
    [AuxKernel]
      type = ParsedAux
      expression = &#x27;T&#x27;
      coupled_variables = &#x27;T&#x27;
      execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
    []
  []
[]

[Kernels]
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cp
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [energy_balance_3]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[BCs]
  [ground]
    type = DirichletBC
    variable = Phi
    boundary = &#x27;PCM_left&#x27;
    value = 0
  []
  [CV]
    type = FunctionDirichletBC
    variable = Phi
    boundary = &#x27;PCM_right&#x27;
    function = 0
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;inlet&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Materials]
  [electrical_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = sigma
    subdomain_to_prop_value = &#x27;PCM ${sigma_PCM} pipe ${sigma_pipe} gas ${sigma_gas}&#x27;
  []
  [charge_trasport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [thermal_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = kappa
    subdomain_to_prop_value = &#x27;PCM ${kappa_PCM} pipe ${kappa_pipe} gas ${kappa_gas}&#x27;
  []
  [density]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = rho
    subdomain_to_prop_value = &#x27;PCM ${rho_PCM} pipe ${rho_pipe} gas ${rho_gas}&#x27;
  []
  [specific_heat]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = cp
    subdomain_to_prop_value = &#x27;PCM ${cp_PCM} pipe ${cp_pipe} gas ${cp_gas}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = H
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv]
    type = ADParsedMaterial
    property_name = qconv
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;100 300&#x27;
    boundary = &#x27;inlet&#x27;
  []
  [delta_enthalpy]
    type = ADParsedMaterial
    property_name = delta_enthalpy
    expression = &#x27;rho*cp*(T-T_old)/2&#x27;
    material_property_names = &#x27;rho cp&#x27;
    coupled_variables = &#x27;T T_old&#x27;
  []
[]

[Postprocessors]
  [Tin]
    type = SideExtremeValue
    variable = T
    value_type = min
    boundary = inlet
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  end_time = ${end_time}
  dtmax = ${dtmax}
  dtmin = 0.01
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    growth_factor = 1.2
    optimal_iterations = 7
    iteration_window = 2
    linear_iteration_ratio = 100000
  []
  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-6
  nl_max_its = 12
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ef7b5a34-74d3-44a4-a8e1-1fdac9adc621"><div class="modal-content"><h4>(examples/LiB/CC_discharging.i)</h4><pre class="moose-pre"><code class="language-text">I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse I/width}&#x27;
t0 = &#x27;${fparse 1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;

sigma_a = 1e0 #mS/mm
sigma_e = 1e-1 #mS/mm
sigma_c = 1e-2 #mS/mm

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmin = 1e-4 #mmol/mm^3
cmax = 1e-3 #mmol/mm^3
D_a = 1e-3 #mm^2/s
D_e = 1e-4 #mm^2/s
D_c = 5e-5 #mm^2/s

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_c = 1e5
E_e = 1e4
E_a = 2e5
nu_c = 0.3
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 60
beta = 1e-3
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s

T_penalty = 2e-1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q zeta m&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Problem]
  restart_file_base = &#x27;CV_charging_I_${I}_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = cathode
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [Phi0]
  []
[]

[ICs]
  [c_ref_min]
    type = ConstantIC
    variable = c_ref
    value = ${cmin}
    block = &#x27;anode&#x27;
  []
  [c_ref_mid]
    type = ConstantIC
    variable = c_ref
    value = &#x27;${fparse (cmax+cmin)/2}&#x27;
    block = &#x27;elyte&#x27;
  []
  [c_ref_max]
    type = ConstantIC
    variable = c_ref
    value = ${cmax}
    block = &#x27;cathode&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;elyte_anode cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;anode_elyte elyte_cathode elyte_anode cathode_elyte&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [left]
    type = FunctionNeumannBC
    variable = Phi
    boundary = left
    function = in
  []
  [right]
    type = DirichletBC
    variable = Phi
    boundary = right
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
[]

[Constraints]
  [y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;anode ${D_a} elyte ${D_e} cathode ${D_c}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Redox
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)&#x27;
    args = c
    block = &#x27;anode&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)&#x27;
    args = c
    block = &#x27;cathode&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_anode&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_cathode&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []

  # Mechanical
  [stiffness_c]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_c*nu_c/(1+nu_c)/(1-2*nu_c)} ${fparse E_c/2/(1+nu_c)}&#x27;
    block = cathode
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = elyte
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = anode
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_a]
    type = Terminator
    expression = &#x27;c_a_min &lt;= ${cmin}&#x27;
    message = &#x27;Concentration in anode is below the minimum allowable value.&#x27;
  []
  [kill_c]
    type = Terminator
    expression = &#x27;c_c_max &gt;= ${cmax}&#x27;
    message = &#x27;Concentration in cathode exceeds the maximum allowable value.&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  start_time = 0
  end_time = 100000
[]

[Outputs]
  file_base = &#x27;CC_discharging_I_${I}&#x27;
  csv = true
  exodus = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="715d7aba-fbd5-4f3e-b36c-6e287ad7390b"><div class="modal-content"><h4>(examples/SSB/charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 1.2e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.5 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 1

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmin_c = 1e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-4 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 60
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;gold/ssb.msh&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = battery
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = VonMisesStress
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [electric_potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;left right&#x27;
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [diffusion]
    type = CondensedMassDiffusion
    mass_flux = j
    mobility = M
    concentration = c
    output_properties = &#x27;j&#x27;
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*in*${width}&#x27;
    pp_names = &#x27;dt in&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [cmin_c]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = &#x27;cp&#x27;
  []
  [cmax_a]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = &#x27;a&#x27;
  []
[]

[UserObjects]
  [kill_a]
    type = Terminator
    expression = &#x27;cmax_a &gt;= ${cmax_a}&#x27;
    message = &#x27;Concentration in anode exceeds the maximum allowable value.&#x27;
  []
  [kill_cp]
    type = Terminator
    expression = &#x27;cmin_c &lt;= ${cmin_c}&#x27;
    message = &#x27;Concentration in cathode particle is below the minimum allowable value.&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  petsc_options_value = &#x27;hypre boomeramg 151 0.25 ext+i PMIS 4 2 0.4&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_factor_mat_solver_package&#x27;
  # petsc_options_value = &#x27;lu superlu_dist&#x27;
  automatic_scaling = true
  # line_search = none
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true

  l_tol = 1e-06
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 12
  l_max_its = 150

  # [TimeStepper]
  #   type = IterationAdaptiveDT
  #   dt = ${dt}
  #   optimal_iterations = 7
  #   iteration_window = 2
  #   growth_factor = 1.2
  #   cutback_factor = 0.2
  #   cutback_factor_at_failure = 0.1
  #   linear_iteration_ratio = 100000
  # []
  [TimeStepper]
    type = FunctionDT
    function = &#x27;if(t&lt;${t0}, ${fparse t0/50}, ${fparse -1e-2/in})&#x27;
    growth_factor = 1.2
    cutback_factor_at_failure = 0.1
  []
  end_time = 100000
[]

[Outputs]
  file_base = &#x27;beta_${beta}&#x27;
  csv = true
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="37279865-30f5-4f3b-9fa7-1d2e45243ccb"><div class="modal-content"><h4>(examples/SSB/CC_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;gold/ssb.msh&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = battery
    add_interface_on_two_sides = true
    split_interface = true
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;V &gt;= 4.6&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  # petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  exodus = true
  csv = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="600f29f0-710c-4131-a82c-fd5b9e74792b"><div class="modal-content"><h4>(examples/SSB_3D/charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 2.5e-4 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.5 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 100

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmin_c = 1e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 5e-1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-4 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 60
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s

T_penalty = 2

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;coarse.e&#x27;
  []
  [scale]
    type = TransformGenerator
    input = battery
    transform = SCALE
    vector_value = &#x27;1e-3 1e-3 1e-3&#x27; #um to mm
  []
  [cathode_particle]
    type = RenameBlockGenerator
    input = scale
    old_block = &#x27;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44&#x27;
    new_block = &#x27;cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp&#x27;
  []
  [cathode_matrix]
    type = RenameBlockGenerator
    input = cathode_particle
    old_block = &#x27;48&#x27;
    new_block = &#x27;cm&#x27;
  []
  [elyte]
    type = RenameBlockGenerator
    input = cathode_matrix
    old_block = 49
    new_block = &#x27;e&#x27;
  []
  [anode]
    type = RenameBlockGenerator
    input = elyte
    old_block = 50
    new_block = &#x27;a&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = anode
    add_interface_on_two_sides = true
    split_interface = true
  []
  [sidesets]
    type = SideSetsFromNormalsGenerator
    input = interfaces
    normals = &#x27;-1 0 0 1 0 0&#x27;
    new_boundary = &#x27;left right&#x27;
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = VonMisesStress
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_z]
    type = InterfaceContinuity
    variable = disp_z
    neighbor_var = disp_z
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;left right&#x27;
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [diffusion]
    type = CondensedMassDiffusion
    mass_flux = j
    mobility = M
    concentration = c
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*in*${width}&#x27;
    pp_names = &#x27;dt in&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [cmin_c]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = &#x27;cp&#x27;
  []
  [cmax_a]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = &#x27;a&#x27;
  []
[]

[UserObjects]
  [kill_a]
    type = Terminator
    expression = &#x27;cmax_a &gt;= ${cmax_a}&#x27;
    message = &#x27;Concentration in anode exceeds the maximum allowable value.&#x27;
  []
  [kill_cp]
    type = Terminator
    expression = &#x27;cmin_c &lt;= ${cmin_c}&#x27;
    message = &#x27;Concentration in cathode particle is below the minimum allowable value.&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  petsc_options_value = &#x27;hypre boomeramg 601 0.6 ext+i PMIS 4 2 0.4&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true

  l_max_its = 600
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 300
  []
  end_time = 10000
[]

[Outputs]
  [exo]
    type = Exodus
    interval = 5
    file_base = &#x27;${outname}_I_${I}&#x27;
  []
  [csv]
    type = CSV
    file_base = &#x27;${outname}_I_${I}&#x27;
  []
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="bcd431d5-36b6-460b-bd4b-777fe378cbdb"><div class="modal-content"><h4>(examples/PCM-GF/discharging.i)</h4><pre class="moose-pre"><code class="language-text"># units are in meter kelvin second (m,kg,s)

end_time = 14400 # 4 hrs

dtmax = 5
dt = 1

sigma_PCM = 5 # (from Wen&#x27;s measurement of Gfoam+PCM in radial direction) (from Cfoam 70% dense foam = 28571.43) S/m (1/electrical resistivity (0.000035 ohm-m))
kappa_PCM = 10 #18.8 # (average of Kxy = 14 W/m-K, Kz = 23.6 W/mK at T=700C) #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
rho_PCM = 2050 # kg/m^3 #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
cp_PCM = 1074 # J/kg-K #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)

sigma_pipe = 750750.75 # S/m (resistivity 1.332e-6 ohm-m at T = 700C) #Special metal data sheet
kappa_pipe = 23.9 # W/m-K (at 700C) #Special metal datasheet
rho_pipe = 8359.33 #kg/m^3
cp_pipe = 419 # J/kg-K

sigma_gas = 1e-12
kappa_gas = 0.03 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
rho_gas = 1.29 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
cp_gas = 1000 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf

htc_gas = 0.1
T_inf_gas = 500

htc_insul = 5
T_inf_insul = 300

T_target = 800

[GlobalParams]
  energy_densities = &#x27;E H&#x27;
[]

[Mesh]
  [fmg]
    type = FileMeshGenerator
    file = &#x27;equilibriate_out.e&#x27;
    use_for_exodus_restart = true
  []
  coord_type = RZ
[]

[Variables]
  [Phi]
  []
  [T]
    initial_from_file_var = T
  []
  [v]
    family = LAGRANGE_VEC
    block = gas
  []
  [p]
    block = gas
  []
[]

[ICs]
  [vel]
    type = VectorConstantIC
    variable = v
    x_value = 1e-15
    y_value = 1e-15
    block = gas
  []
[]

[AuxVariables]
  [T_old]
    [AuxKernel]
      type = ParsedAux
      expression = &#x27;T&#x27;
      coupled_variables = &#x27;T&#x27;
      execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
    []
  []
[]

[Kernels]
  [mass]
    type = INSADMass
    variable = p
    block = gas
  []
  [pspg]
    type = INSADMassPSPG
    variable = p
    block = gas
  []
  [momentum_convection]
    type = INSADMomentumAdvection
    variable = v
    block = gas
  []
  [momentum_viscous]
    type = INSADMomentumViscous
    variable = v
    block = gas
  []
  [momentum_pressure]
    type = INSADMomentumPressure
    variable = v
    pressure = p
    integrate_p_by_parts = true
    block = gas
  []
  [momentum_supg]
    type = INSADMomentumSUPG
    variable = v
    velocity = v
    block = gas
  []

  [temperature_advection]
    type = INSADEnergyAdvection
    variable = T
    block = gas
  []
  [temperature_supg]
    type = INSADEnergySUPG
    variable = T
    velocity = v
    block = gas
  []
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cp
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [energy_balance_3]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[BCs]
  [ground]
    type = DirichletBC
    variable = Phi
    boundary = &#x27;PCM_left&#x27;
    value = 0
  []
  [voltage]
    type = TargetFeedbackDirichletBC
    variable = Phi
    monitor = T_outlet
    target = ${T_target}
    window = &#x27;${fparse 0.02*T_target}&#x27;
    idle_value = 0
    maintain_value = 12
    compensate_value = 20
    boundary = &#x27;PCM_right&#x27;
  []
  [T_inlet]
    type = DirichletBC
    variable = T
    value = 300
    boundary = &#x27;inlet&#x27;
  []
  [velocity_inlet]
    type = VectorFunctionDirichletBC
    variable = v
    function_y = 0.1
    boundary = &#x27;inlet&#x27;
  []
  [wall]
    type = VectorFunctionDirichletBC
    variable = v
    boundary = &#x27;wall&#x27;
  []
  [hconv_outlet]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;outlet&#x27;
    value = -1
    boundary_material = qconv_outlet
  []
  [hconv_insul]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;insul PCM_right&#x27;
    value = -1
    boundary_material = qconv_insul
  []
[]

[Materials]
  [constant]
    type = ADGenericConstantMaterial
    prop_names = &#x27;mu&#x27;
    prop_values = &#x27;1.8e-5&#x27;
  []
  [ins]
    type = INSADStabilized3Eqn
    pressure = p
    velocity = v
    temperature = T
    k_name = kappa
    block = gas
  []
  [electrical_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = sigma
    subdomain_to_prop_value = &#x27;PCM ${sigma_PCM} pipe ${sigma_pipe} gas ${sigma_gas}&#x27;
  []
  [charge_trasport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [thermal_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = kappa
    subdomain_to_prop_value = &#x27;PCM ${kappa_PCM} pipe ${kappa_pipe} gas ${kappa_gas}&#x27;
  []
  [density]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = rho
    subdomain_to_prop_value = &#x27;PCM ${rho_PCM} pipe ${rho_pipe} gas ${rho_gas}&#x27;
  []
  [specific_heat]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = cp
    subdomain_to_prop_value = &#x27;PCM ${cp_PCM} pipe ${cp_pipe} gas ${cp_gas}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = H
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv_outlet]
    type = ADParsedMaterial
    property_name = qconv_outlet
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${htc_gas} ${T_inf_gas}&#x27;
    boundary = &#x27;outlet&#x27;
  []
  [qconv_insul]
    type = ADParsedMaterial
    property_name = qconv_insul
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${htc_insul} ${T_inf_insul}&#x27;
    boundary = &#x27;insul PCM_right&#x27;
  []
  [delta_enthalpy]
    type = ADParsedMaterial
    property_name = delta_enthalpy
    expression = &#x27;rho*cp*(T-T_old)/2&#x27;
    material_property_names = &#x27;rho cp&#x27;
    coupled_variables = &#x27;T T_old&#x27;
  []
[]

[Postprocessors]
  [T_outlet]
    type = SideAverageValue
    variable = T
    boundary = &#x27;outlet&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;lu       NONZERO&#x27;
  automatic_scaling = true

  end_time = ${end_time}
  dtmax = ${dtmax}
  dtmin = 0.01
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    growth_factor = 1.2
    optimal_iterations = 7
    iteration_window = 2
    linear_iteration_ratio = 100000
  []
  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-6
  nl_max_its = 12
[]

[Outputs]
  file_base = &#x27;T_target_${T_target}&#x27;
  exodus = true
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="d0d6e79c-9145-40b7-a260-3eb6c860cbb6"><div class="modal-content"><h4>(examples/PCM-GF/charging_idling.i)</h4><pre class="moose-pre"><code class="language-text"># units are in meter kelvin second (m,kg,s)

tramp = 10
tcharge = 8000 # 3hr*3600
tidle = 86400 #24hr*3600
end_time = &#x27;${fparse tcharge+tidle}&#x27;

dtmax = 600
dt = 1

T_melting = &#x27;${fparse 718+273.15}&#x27; # Temperature at which the melting begins, Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
delta_T_pc = 8 # The temperature range of the melting/solidification process
L = 373.9e3 # Latent heat, from Singh et al. (2015)

sigma_foam_PCM = 5 # (from Wen&#x27;s measurement of Gfoam+PCM in radial direction) (from Cfoam 70% dense foam = 28571.43) S/m (1/electrical resistivity (0.000035 ohm-m))
kappa_foam_PCM = 10 #18.8 # (average of Kxy = 14 W/m-K, Kz = 23.6 W/mK at T=700C) #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
rho_foam_PCM = 2050 # kg/m^3 #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)
cp_foam_PCM = 1074 # J/kg-K #from Singh et al. Solar energy 159(2018) 270-282 (Prototype 1)

sigma_htf_pipe = 750750.75 # S/m (resistivity 1.332e-6 ohm-m at T = 700C) #Special metal data sheet
kappa_htf_pipe = 23.9 # W/m-K (at 700C) #Special metal datasheet
rho_htf_pipe = 8359.33 #kg/m^3
cp_htf_pipe = 419 # J/kg-K

sigma_insul_ht = 1e-9
kappa_insul_ht = 0.12 # W/m-K(Durablanket S from UNIFRAX) Wen emailed on 2023-03-31
rho_insul_ht = 2730 # kg/m^3(Durablanket S from UNIFRAX) Wen emailed on 2023-03-31
cp_insul_ht = 1130 # J/kg-K(Durablanket S from UNIFRAX) Wen emailed on 2023-03-31

sigma_air = 1e-12
kappa_air = 0.03 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
rho_air = 1.29 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf
cp_air = 1000 #file:///C:/Users/barua/Downloads/PDS-FOAMGLAS%20ONE-US-en.pdf

htc_insul = 5
T_inf_insul = 300
htc_pipe = 0.01
T_inf_pipe = 300
T0 = 300
# i = 1 # This is the maximum current in constant-current charging
V = 21 # This is the maximum voltage in constant-voltage charging

[GlobalParams]
  energy_densities = &#x27;E H&#x27;
[]

[Mesh]
  [fmg]
    type = FileMeshGenerator
    file = &#x27;gold/geo.e&#x27;
  []
  coord_type = RZ
  uniform_refine = 1
[]

[Variables]
  [Phi]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [T_old]
    [AuxKernel]
      type = ParsedAux
      expression = &#x27;T&#x27;
      coupled_variables = &#x27;T&#x27;
      execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
    []
  []
[]

[Kernels]
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cp
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [energy_balance_3]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[Functions]
  # [ramp_current]
  #   type = PiecewiseLinear
  #   x = &#x27;0 ${t0}&#x27;
  #   y = &#x27;0 ${i}&#x27;
  # []
  [ramp_voltage]
    type = PiecewiseLinear
    x = &#x27;0 ${tramp} ${tcharge} ${fparse tcharge+tramp} ${fparse tcharge+tidle}&#x27;
    y = &#x27;0 ${V} ${V} 0 0&#x27;
  []
[]

[BCs]
  [ground]
    type = DirichletBC
    variable = Phi
    boundary = &#x27;foam_id&#x27;
    value = 0
  []
  # [current]
  #   type = FunctionNeumannBC
  #   variable = Phi
  #   boundary = &#x27;foam_od&#x27;
  #   function = ramp_current
  # []
  [CV]
    type = FunctionDirichletBC
    variable = Phi
    boundary = &#x27;foam_od&#x27;
    function = ramp_voltage
  []
  [hconv_insul]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;insul_surf&#x27;
    value = -1
    boundary_material = qconv_insul
  []
  [hconv_pipe]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;pipe_id&#x27;
    value = -1
    boundary_material = qconv_pipe
  []
[]

[Materials]
  [electrical_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = sigma
    subdomain_to_prop_value = &#x27;foam_PCM ${sigma_foam_PCM} htf_pipe ${sigma_htf_pipe} insul_ht ${sigma_insul_ht} air ${sigma_air}&#x27;
  []
  [charge_trasport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [thermal_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = kappa
    subdomain_to_prop_value = &#x27;foam_PCM ${kappa_foam_PCM} htf_pipe ${kappa_htf_pipe} insul_ht ${kappa_insul_ht} air ${kappa_air}&#x27;
  []
  [density]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = rho
    subdomain_to_prop_value = &#x27;foam_PCM ${rho_foam_PCM} htf_pipe ${rho_htf_pipe} insul_ht ${rho_insul_ht} air ${rho_air}&#x27;
  []
  [gaussian_function]
    type = ADParsedMaterial
    property_name = D
    expression = &#x27;exp(-T*(T-Tm)^2/dT^2)/sqrt(3.1415926*dT^2)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;Tm dT&#x27;
    constant_expressions = &#x27;${T_melting} ${delta_T_pc}&#x27;
  []
  [specific_heat_foam_PCM]
    type = ADParsedMaterial
    property_name = cp
    expression = &#x27;${cp_foam_PCM} + ${L} * D&#x27;
    material_property_names = &#x27;D&#x27;
    block = foam_PCM
    outputs = exodus
  []
  [specific_heat]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = cp
    subdomain_to_prop_value = &#x27;htf_pipe ${cp_htf_pipe} insul_ht ${cp_insul_ht} air ${cp_air}&#x27;
    block = &#x27;htf_pipe insul_ht air&#x27;
    outputs = exodus
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = H
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv_insul]
    type = ADParsedMaterial
    property_name = qconv_insul
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${htc_insul} ${T_inf_insul}&#x27;
    boundary = &#x27;insul_surf&#x27;
  []
  [qconv_pipe]
    type = ADParsedMaterial
    property_name = qconv_pipe
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${htc_pipe} ${T_inf_pipe}&#x27;
    boundary = &#x27;pipe_id&#x27;
  []
  [delta_enthalpy]
    type = ADParsedMaterial
    property_name = delta_enthalpy
    expression = &#x27;rho*cp*(T-T_old)/2&#x27;
    material_property_names = &#x27;rho cp&#x27;
    coupled_variables = &#x27;T T_old&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  end_time = ${end_time}
  dtmax = ${dtmax}
  dtmin = 0.01
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    growth_factor = 1.2
    optimal_iterations = 7
    iteration_window = 2
    linear_iteration_ratio = 100000
  []
  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  nl_abs_tol = 1e-8
  nl_rel_tol = 1e-6
  nl_max_its = 12

  # steady_state_detection = true
[]

[Postprocessors]
  [volume_PCM]
    type = VolumePostprocessor
    block = &#x27;foam_PCM&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    # outputs = none
  []
  [delta_energy_absorbed_by_PCM]
    type = ADElementIntegralMaterialProperty
    mat_prop = delta_enthalpy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    block = &#x27;foam_PCM&#x27;
    outputs = none
  []
  [delta_energy_absorbed_by_insul_ht]
    type = ADElementIntegralMaterialProperty
    mat_prop = delta_enthalpy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    block = &#x27;insul_ht&#x27;
    outputs = none
  []
  [delta_energy_absorbed_by_air]
    type = ADElementIntegralMaterialProperty
    mat_prop = delta_enthalpy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    block = &#x27;air&#x27;
    outputs = none
  []
  [delta_energy_absorbed_by_pipe]
    type = ADElementIntegralMaterialProperty
    mat_prop = delta_enthalpy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    block = &#x27;htf_pipe&#x27;
    outputs = none
  []
  [energy_absorbed_by_PCM]
    type = CumulativeValuePostprocessor
    postprocessor = delta_energy_absorbed_by_PCM
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [energy_absorbed_by_insul_ht]
    type = CumulativeValuePostprocessor
    postprocessor = delta_energy_absorbed_by_insul_ht
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [energy_absorbed_by_air]
    type = CumulativeValuePostprocessor
    postprocessor = delta_energy_absorbed_by_air
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [energy_absorbed_by_pipe]
    type = CumulativeValuePostprocessor
    postprocessor = delta_energy_absorbed_by_pipe
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [total_energy]
    type = ParsedPostprocessor
    pp_names = &#x27;energy_absorbed_by_PCM energy_absorbed_by_insul_ht energy_absorbed_by_air energy_absorbed_by_pipe&#x27;
    function = &#x27;energy_absorbed_by_PCM+energy_absorbed_by_insul_ht+energy_absorbed_by_air+energy_absorbed_by_pipe&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [max_energy]
    type = TimeExtremeValue
    postprocessor = total_energy
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [energy_percentage]
    type = ParsedPostprocessor
    pp_names = &#x27;total_energy max_energy&#x27;
    function = &#x27;if(total_energy &lt; max_energy, total_energy/max_energy*100, 100)&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [power_input]
    type = ADElementIntegralMaterialProperty
    mat_prop = E
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    # outputs = none
  []
  [voltage]
    type = FunctionValuePostprocessor
    function = ramp_voltage
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    # outputs = none
  []
  [current_input]
    type = ParsedPostprocessor
    pp_names = &#x27;voltage power_input&#x27;
    function = &#x27;power_input / voltage&#x27;
    execute_on = &#x27;TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [delta_energy_input]
    type = ParsedPostprocessor
    pp_names = &#x27;dt power_input&#x27;
    function = &#x27;power_input * dt&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    outputs = none
  []
  [energy_input]
    type = CumulativeValuePostprocessor
    postprocessor = delta_energy_input
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [PCM_max_temperature]
    type = NodalExtremeValue
    variable = T
    value_type = max
    block = &#x27;foam_PCM&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [PCM_min_temperature]
    type = NodalExtremeValue
    variable = T
    value_type = min
    block = &#x27;foam_PCM&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="c124c05a-f4eb-4ed0-b545-2a1b35db3c00"><div class="modal-content"><h4>(examples/SSB_3D/CC_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;../coarse.e&#x27;
  []
  [scale]
    type = TransformGenerator
    input = battery
    transform = SCALE
    vector_value = &#x27;1e-3 1e-3 1e-3&#x27; #um to mm
  []
  [cathode_particle]
    type = RenameBlockGenerator
    input = scale
    old_block = &#x27;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44&#x27;
    new_block = &#x27;cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp&#x27;
  []
  [cathode_matrix]
    type = RenameBlockGenerator
    input = cathode_particle
    old_block = &#x27;48&#x27;
    new_block = &#x27;cm&#x27;
  []
  [elyte]
    type = RenameBlockGenerator
    input = cathode_matrix
    old_block = 49
    new_block = &#x27;e&#x27;
  []
  [anode]
    type = RenameBlockGenerator
    input = elyte
    old_block = 50
    new_block = &#x27;a&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = anode
    add_interface_on_two_sides = true
    split_interface = true
  []
  [sidesets]
    type = SideSetsFromNormalsGenerator
    input = interfaces
    normals = &#x27;-1 0 0 1 0 0 0 -1 0 0 1 0 0 0 -1 0 0 1&#x27;
    new_boundary = &#x27;left right bottom top back front&#x27;
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_z]
    type = InterfaceContinuity
    variable = disp_z
    neighbor_var = disp_z
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
  [ev_z]
    type = EqualValueBoundaryConstraint
    variable = disp_z
    penalty = ${u_penalty}
    secondary = front
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;V &gt;= 4.6&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  petsc_options_value = &#x27;hypre boomeramg 301 0.7 ext+i PMIS 4 2 0.4&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  file_base = &#x27;${outname}_CC_charging&#x27;
  exodus = true
  csv = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="3a4fe352-db24-42ff-b3bd-243a7ce0cd5c"><div class="modal-content"><h4>(examples/SSB/CV_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  restart_file_base = &#x27;CC_charging_out_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;gold/ssb.msh&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = battery
    add_interface_on_two_sides = true
    split_interface = true
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
    [AuxKernel]
      type = ParsedAux
      function = &#x27;Phi&#x27;
      args = &#x27;Phi&#x27;
      execute_on = &#x27;INITIAL&#x27;
    []
  []
[]

[ICs]
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = CoupledVarDirichletBC
    variable = Phi
    boundary = right
    value = Phi0
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;I &lt;= 1e-6&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  # petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  exodus = true
  csv = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="b4c3ba2d-5196-437c-aea6-8ccba5e4787e"><div class="modal-content"><h4>(examples/SSB_3D/CC_discharging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Problem]
  restart_file_base = &#x27;${outname}_CV_charging_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;../coarse.e&#x27;
  []
  [scale]
    type = TransformGenerator
    input = battery
    transform = SCALE
    vector_value = &#x27;1e-3 1e-3 1e-3&#x27; #um to mm
  []
  [cathode_particle]
    type = RenameBlockGenerator
    input = scale
    old_block = &#x27;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44&#x27;
    new_block = &#x27;cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp&#x27;
  []
  [cathode_matrix]
    type = RenameBlockGenerator
    input = cathode_particle
    old_block = &#x27;48&#x27;
    new_block = &#x27;cm&#x27;
  []
  [elyte]
    type = RenameBlockGenerator
    input = cathode_matrix
    old_block = 49
    new_block = &#x27;e&#x27;
  []
  [anode]
    type = RenameBlockGenerator
    input = elyte
    old_block = 50
    new_block = &#x27;a&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = anode
    add_interface_on_two_sides = true
    split_interface = true
  []
  [sidesets]
    type = SideSetsFromNormalsGenerator
    input = interfaces
    normals = &#x27;-1 0 0 1 0 0 0 -1 0 0 1 0 0 0 -1 0 0 1&#x27;
    new_boundary = &#x27;left right bottom top back front&#x27;
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
  []
[]

[ICs]
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_z]
    type = InterfaceContinuity
    variable = disp_z
    neighbor_var = disp_z
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${fparse -in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
  [ev_z]
    type = EqualValueBoundaryConstraint
    variable = disp_z
    penalty = ${u_penalty}
    secondary = front
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;V &lt;= 2.5&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  file_base = &#x27;${outname}_CC_discharging&#x27;
  exodus = true
  csv = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="63effe3e-b791-4e5e-ab51-d22dfc38271a"><div class="modal-content"><h4>(examples/cable/cable.i)</h4><pre class="moose-pre"><code class="language-text">R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

in = &#x27;${fparse 1e3/pi/34^2}&#x27;

sigma_con = 1

c_ref = 1e-3
c_ref_ent = 1e-6
M_con = 1e-1

kappa_con = 398 #mJ/mm/K/s
kappa_air = 3.98 #mJ/mm/K/s
kappa_ins = 0.29 #mJ/mm/K/s
kappa_jac = 0.39 #mJ/mm/K/s

E_con = 1.1e5
E_air = 1e2
E_ins = 6e2
E_jac = 3e2
nu_con = 0.32
nu_air = 0.25
nu_ins = 0.4
nu_jac = 0.3

CTE = 1e-5

htc = 1e1

[GlobalParams]
  energy_densities = &#x27;q dot(psi_c) zeta m chi dot(psi_m)&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  thermal_deformation_gradient = Ft
[]

[Problem]
  kernel_coverage_check = false
  material_coverage_check = false
[]

[Mesh]
  [fmg]
    type = FileMeshGenerator
    file = &#x27;gold/cable.msh&#x27;
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi]
    block = &#x27;conductor&#x27;
  []
  [c]
    initial_condition = ${c_ref}
    block = &#x27;conductor&#x27;
  []
  [T]
    initial_condition = ${T0}
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
[]

[AuxVariables]
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
[]

[Functions]
  [current_density]
    type = PiecewiseLinear
    x = &#x27;0 100&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
    block = &#x27;conductor&#x27;
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
    block = &#x27;conductor&#x27;
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
    block = &#x27;conductor&#x27;
  []
  # Energy balance
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = pk1
    factor = -1
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = &#x27;conductor_top&#x27;
    function = current_density
  []
  [Phi_ref]
    type = DirichletBC
    variable = Phi
    boundary = &#x27;conductor_bottom&#x27;
    value = 0
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;outer&#x27;
    value = -1
    boundary_material = qconv
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    boundary = &#x27;center piny&#x27;
    value = 0
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    boundary = &#x27;center pinx&#x27;
    value = 0
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    boundary = &#x27;conductor_bottom air_bottom insulator_bottom jacket_bottom&#x27;
    value = 0
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;conductor ${sigma_con}&#x27;
    block = &#x27;conductor&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
    block = &#x27;conductor&#x27;
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    block = &#x27;conductor&#x27;
  []

  # Chemistry
  [mobility]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;M&#x27;
    subdomain_to_prop_value = &#x27;conductor ${M_con}&#x27;
    block = &#x27;conductor&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = ${c_ref_ent}
    block = &#x27;conductor&#x27;
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    block = &#x27;conductor&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
    block = &#x27;conductor&#x27;
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    block = &#x27;conductor&#x27;
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
    block = &#x27;conductor&#x27;
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
    block = &#x27;conductor&#x27;
  []

  # Thermal
  [heat_conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;kappa&#x27;
    subdomain_to_prop_value = &#x27;conductor ${kappa_con} air ${kappa_air} insulator ${kappa_ins} jacket ${kappa_jac}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;htc*(T-T_inf)&#x27;
    args = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${htc} ${T0}&#x27;
    boundary = &#x27;outer&#x27;
  []

  # Mechanics
  [youngs_modulus]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;lambda&#x27;
    subdomain_to_prop_value = &#x27;conductor ${fparse E_con*nu_con/(1+nu_con)/(1-2*nu_con)} air ${fparse E_air*nu_air/(1+nu_air)/(1-2*nu_air)} insulator ${fparse E_ins*nu_ins/(1+nu_ins)/(1-2*nu_ins)} jacket ${fparse E_jac*nu_jac/(1+nu_jac)/(1-2*nu_jac)}&#x27;
  []
  [poissons_ratio]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;G&#x27;
    subdomain_to_prop_value = &#x27;conductor ${fparse E_con/2/(1+nu_con)} air ${fparse E_air/2/(1+nu_air)} insulator ${fparse E_ins/2/(1+nu_ins)} jacket ${fparse E_jac/2/(1+nu_jac)}&#x27;
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = ${T0}
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y disp_z&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [T_max]
    type = NodalExtremeValue
    variable = T
    block = &#x27;conductor&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  # petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T c&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-8
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = FunctionDT
    function = &#x27;if(t&lt;100,10,100)&#x27;
  []
  end_time = 100
[]

[Outputs]
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="9ef50c8f-bf80-4d0d-8b47-ac9be74e455e"><div class="modal-content"><h4>(test/tests/chemical-electrical-thermal/thermal_effects.i)</h4><pre class="moose-pre"><code class="language-text">R = 8.3145 #mJ/mmol/K
F = 96485 #mC/mmol

I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;
Vmax = 4.3 #V

vf_se = 0.3
vf_cp = 0.5
vf_ca = 0.2

sigma_a = 0.2 #mS/mm
sigma_se = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_e = ${sigma_se}
sigma_c = &#x27;${fparse vf_se*sigma_se + vf_cp*sigma_cp + vf_ca*sigma_ca}&#x27;

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmax = 1e-3 #mmol/mm^3
c0_a = 1e-4
c0_e = 5e-4
c0_c = 1e-3

M_a = 8e-11
M_se = 1e-11
M_cp = 4e-14
M_ca = 1e-13
M_e = ${M_se}
M_c = &#x27;${fparse vf_se*M_se + vf_cp*M_cp + vf_ca*M_ca}&#x27;

T0 = 300 #K

i0_a = 0.1 #mA/mm^2
i0_c = 0.1 #mA/mm^2

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
hconv = 9.5e-3 #mJ/mm^2/K/s

T_penalty = 2e-1

[GlobalParams]
  energy_densities = &#x27;dot(psi_c) q zeta chi m&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [anode_elyte]
    type = BreakMeshByBlockGenerator
    input = cathode
    block_pairs = &#x27;1 2&#x27;
    add_interface_on_two_sides = true
    split_interface = true
  []
  [cathode_elyte]
    type = BreakMeshByBlockGenerator
    input = anode_elyte
    block_pairs = &#x27;2 3&#x27;
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${c0_a}
    block = &#x27;anode&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c0_e}
    block = &#x27;elyte&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${c0_c}
    block = &#x27;cathode&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${c0_a}
    block = &#x27;anode&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c0_e}
    block = &#x27;elyte&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${c0_c}
    block = &#x27;cathode&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    factor_neighbor = 1
    boundary = &#x27;cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    factor_neighbor = 1
    boundary = &#x27;anode_elyte cathode_elyte&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;anode_elyte cathode_elyte&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [left]
    type = FunctionNeumannBC
    variable = Phi
    boundary = left
    function = in
  []
  [right]
    type = DirichletBC
    variable = Phi
    boundary = right
    value = 0
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;M&#x27;
    subdomain_to_prop_value = &#x27;anode ${M_a} elyte ${M_e} cathode ${M_c}&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
    reference_chemical_potential = 1e3
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    coupled_variables = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;anode_elyte&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    coupled_variables = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv]
    type = ADParsedMaterial
    property_name = qconv
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${hconv} ${T0}&#x27;
    boundary = &#x27;left right&#x27;
  []
  [enthalpy]
    type = ADParsedMaterial
    f_name = enthalpy
    function = &#x27;rho*cv*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    material_property_names = &#x27;rho cv&#x27;
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*in*${width}&#x27;
    pp_names = &#x27;dt in&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [H_a]
    type = ADElementIntegralMaterialProperty
    mat_prop = enthalpy
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [H_e]
    type = ADElementIntegralMaterialProperty
    mat_prop = enthalpy
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [H_c]
    type = ADElementIntegralMaterialProperty
    mat_prop = enthalpy
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill]
    type = Terminator
    expression = &#x27;V &gt;= ${Vmax}&#x27;
    message = &#x27;Voltage reached Vmax&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  line_search = none

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20
  l_max_its = 150

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  dtmax = 1
  end_time = 100000
[]

[Outputs]
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ee901013-7c10-4290-a8df-52435d444b04"><div class="modal-content"><h4>(examples/SSB_3D/CV_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y disp_z&#x27;
[]

[Problem]
  restart_file_base = &#x27;${outname}_CC_charging_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;../coarse.e&#x27;
  []
  [scale]
    type = TransformGenerator
    input = battery
    transform = SCALE
    vector_value = &#x27;1e-3 1e-3 1e-3&#x27; #um to mm
  []
  [cathode_particle]
    type = RenameBlockGenerator
    input = scale
    old_block = &#x27;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44&#x27;
    new_block = &#x27;cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp cp&#x27;
  []
  [cathode_matrix]
    type = RenameBlockGenerator
    input = cathode_particle
    old_block = &#x27;48&#x27;
    new_block = &#x27;cm&#x27;
  []
  [elyte]
    type = RenameBlockGenerator
    input = cathode_matrix
    old_block = 49
    new_block = &#x27;e&#x27;
  []
  [anode]
    type = RenameBlockGenerator
    input = elyte
    old_block = 50
    new_block = &#x27;a&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = anode
    add_interface_on_two_sides = true
    split_interface = true
  []
  [sidesets]
    type = SideSetsFromNormalsGenerator
    input = interfaces
    normals = &#x27;-1 0 0 1 0 0 0 -1 0 0 1 0 0 0 -1 0 0 1&#x27;
    new_boundary = &#x27;left right bottom top back front&#x27;
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [disp_z]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
    [AuxKernel]
      type = ParsedAux
      function = &#x27;Phi&#x27;
      args = &#x27;Phi&#x27;
      execute_on = &#x27;INITIAL&#x27;
    []
  []
[]

[ICs]
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  [momentum_balance_z]
    type = RankTwoDivergence
    variable = disp_z
    component = 2
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_z]
    type = InterfaceContinuity
    variable = disp_z
    neighbor_var = disp_z
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [current]
    type = CoupledVarDirichletBC
    variable = Phi
    boundary = right
    value = Phi0
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [fix_z]
    type = DirichletBC
    variable = disp_z
    value = 0
    boundary = &#x27;back&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
  [ev_z]
    type = EqualValueBoundaryConstraint
    variable = disp_z
    penalty = ${u_penalty}
    secondary = front
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;I &lt;= 1e-6&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  file_base = &#x27;${outname}_CV_charging&#x27;
  exodus = true
  csv = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="4e196f5a-8941-4faf-9756-107d41afb371"><div class="modal-content"><h4>(test/tests/chemical-electrical-thermal-mechanical/pressure.i)</h4><pre class="moose-pre"><code class="language-text">R = 8.3145 #mJ/mmol/K
F = 96485 #mC/mmol

I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;
Vmax = 4.3 #V

vf_se = 0.3
vf_cp = 0.5
vf_ca = 0.2

sigma_a = 0.2 #mS/mm
sigma_se = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_e = ${sigma_se}
sigma_c = &#x27;${fparse vf_se*sigma_se + vf_cp*sigma_cp + vf_ca*sigma_ca}&#x27;

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmax = 1e-3 #mmol/mm^3
c0_a = 1e-4
c0_e = 5e-4
c0_c = 1e-3

M_a = 8e-11
M_se = 1e-11
M_cp = 4e-14
M_ca = 1e-13
M_e = ${M_se}
M_c = &#x27;${fparse vf_se*M_se + vf_cp*M_cp + vf_ca*M_ca}&#x27;

T0 = 300 #K

i0_a = 0.1 #mA/mm^2
i0_c = 0.1 #mA/mm^2

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
hconv = 9.5e-3 #mJ/mm^2/K/s

T_penalty = 2e-1

E_e = 1e4
E_a = 2e5
nu_e = 0.25
nu_a = 0.3
nu_c = 0.3

d = 0
E_e_bar = &#x27;${fparse E_e/(1-nu_e*nu_e)}&#x27;
E_c_bar = &#x27;${fparse (1+d)/(1-d)*E_e_bar}&#x27;
E_c = &#x27;${fparse (1-nu_c*nu_c)*E_c_bar}&#x27;

Omega = 140
beta = 1
CTE = 1e-5

u_penalty = 1e8

P = 10
center = 0.12
spread = 0.01

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) q zeta chi m&#x27;
  displacements = &#x27;disp_x disp_y&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [anode_elyte]
    type = BreakMeshByBlockGenerator
    input = cathode
    block_pairs = &#x27;1 2&#x27;
    add_interface_on_two_sides = true
    split_interface = true
  []
  [cathode_elyte]
    type = BreakMeshByBlockGenerator
    input = anode_elyte
    block_pairs = &#x27;2 3&#x27;
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [T]
    initial_condition = ${T0}
  []
  [disp_x]
  []
  [disp_y]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [j]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADMaterialRealVectorValueAux
      property = j
      component = 0
    []
  []
[]

[ICs]
  [c_a]
    type = ConstantIC
    variable = c
    value = ${c0_a}
    block = &#x27;anode&#x27;
  []
  [c_e]
    type = ConstantIC
    variable = c
    value = ${c0_e}
    block = &#x27;elyte&#x27;
  []
  [c_c]
    type = ConstantIC
    variable = c
    value = ${c0_c}
    block = &#x27;cathode&#x27;
  []
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${c0_a}
    block = &#x27;anode&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c0_e}
    block = &#x27;elyte&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${c0_c}
    block = &#x27;cathode&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
    use_displaced_mesh = true
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
    use_displaced_mesh = true
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
    use_displaced_mesh = true
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    factor_neighbor = 1
    boundary = &#x27;cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    factor_neighbor = 1
    boundary = &#x27;anode_elyte cathode_elyte&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [left]
    type = FunctionNeumannBC
    variable = Phi
    boundary = left
    function = in
  []
  [right]
    type = DirichletBC
    variable = Phi
    boundary = right
    value = 0
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [traction]
    enable = false
    type = FunctionNeumannBC
    variable = disp_y
    boundary = &#x27;top&#x27;
    function = &#x27;-if(t&lt;${t0},t/${t0}*${P},${P})/${spread}/sqrt(2*pi)*exp(-0.5*(x-${center})^2/${spread}^2)&#x27;
  []
[]

[Constraints]
  [y]
    enable = false
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;M&#x27;
    subdomain_to_prop_value = &#x27;anode ${M_a} elyte ${M_e} cathode ${M_c}&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
    reference_chemical_potential = 1e3
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    coupled_variables = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;anode_elyte&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    property_name = U
    expression = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    coupled_variables = c
    material_property_names = &#x27;ramp&#x27;
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv]
    type = ADParsedMaterial
    property_name = qconv
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;${hconv} ${T0}&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_c]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_c*nu_c/(1+nu_c)/(1-2*nu_c)} ${fparse E_c/2/(1+nu_c)}&#x27;
    block = cathode
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = elyte
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = anode
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [in]
    type = FunctionValuePostprocessor
    function = in
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*in*${width}&#x27;
    pp_names = &#x27;dt in&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [E_c_bar]
    type = ParsedPostprocessor
    function = &#x27;${E_c_bar}&#x27;
    execute_on = INITIAL
    pp_names = &#x27;&#x27;
  []
[]

[UserObjects]
  [kill]
    type = Terminator
    expression = &#x27;V &gt;= ${Vmax}&#x27;
    message = &#x27;Voltage reached Vmax&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  line_search = none

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20
  l_max_its = 150

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  dtmax = 1
  end_time = 100000
[]

[Outputs]
  exodus = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f3a3bb8c-c2f8-4f86-82b5-93fe3cfc9af9"><div class="modal-content"><h4>(examples/SSB/CC_discharging.i)</h4><pre class="moose-pre"><code class="language-text">I = 0.005 #mA
width = 0.05 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;

sigma_a = 0.2 #mS/mm
sigma_e = 0.1 #mS/mm
sigma_cp = 0.05 #mS/mm
sigma_ca = 0.2 #mS/mm
sigma_cm = 0.05 #mS/mm

Phi_penalty = 10

cmin_a = 1e-4 #mmol/mm^3
cmax_a = 1e-3 #mmol/mm^3
c_e = 5e-4 #mmol/mm^3
cmax_c = 1e-3 #mmol/mm^3
c_ref_entropy = 5e-5
D_cp = 5e-5 #mm^2/s
D_cm = 1e-4 #mm^2/s
D_a = 5e-4 #mm^2/s
D_e = 1e-4 #mm^2/s

c_penalty = 1

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_cp = 6e4
E_cm = 5e4
E_e = 5e4
E_a = 1e5
nu_cp = 0.3
nu_cm = 0.25
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 140
beta = 1e-4
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s
htc = 9.5e-3

T_penalty = 1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Problem]
  restart_file_base = &#x27;CV_charging_out_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = FileMeshGenerator
    file = &#x27;gold/ssb.msh&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = battery
    add_interface_on_two_sides = true
    split_interface = true
  []
  use_displaced_mesh = false
[]

[Variables]
  [Phi_ca]
    block = cm
  []
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [stress]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = pk1
      scalar_type = Hydrostatic
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Js]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Fs
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Jt]
    order = CONSTANT
    family = MONOMIAL
    [AuxKernel]
      type = ADRankTwoScalarAux
      rank_two_tensor = Ft
      scalar_type = ThirdInvariant
      execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
    []
  []
  [Phi0]
  []
[]

[ICs]
  [c_ref_a]
    type = ConstantIC
    variable = c_ref
    value = ${cmin_a}
    block = &#x27;a&#x27;
  []
  [c_ref_e]
    type = ConstantIC
    variable = c_ref
    value = ${c_e}
    block = &#x27;cm e&#x27;
  []
  [c_ref_c]
    type = ConstantIC
    variable = c_ref
    value = ${cmax_c}
    block = &#x27;cp&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge_balance_ca]
    type = RankOneDivergence
    variable = Phi_ca
    vector = i_ca
    block = cm
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [negative_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = -1
    boundary = &#x27;e_a cp_cm&#x27;
  []
  [positive_mass]
    type = MaterialInterfaceNeumannBC
    variable = c
    neighbor_var = c
    prop = je
    factor = 1
    boundary = &#x27;a_e cm_cp&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;a_e cm_cp e_a cp_cm&#x27;
  []
  [continuity_c]
    type = InterfaceContinuity
    variable = c
    neighbor_var = c
    penalty = ${c_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_Phi_ca]
    type = InterfaceContinuity
    variable = Phi_ca
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_cp&#x27;
  []
  [continuity_Phi]
    type = InterfaceContinuity
    variable = Phi
    neighbor_var = Phi
    penalty = ${Phi_penalty}
    boundary = &#x27;cm_e&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;cp_cm cm_e e_a&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${fparse -in}&#x27;
  []
[]

[BCs]
  [current]
    type = FunctionNeumannBC
    variable = Phi
    boundary = right
    function = in
  []
  [potential]
    type = DirichletBC
    variable = Phi_ca
    boundary = left
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = &#x27;left right&#x27;
    value = -1
    boundary_material = qconv
  []
[]

[Constraints]
  [ev_y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;a ${sigma_a} e ${sigma_e} cm ${sigma_cm} cp ${sigma_cp}&#x27;
  []
  [conductivity_ca]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma_ca&#x27;
    subdomain_to_prop_value = &#x27;cm ${sigma_ca}&#x27;
    block = cm
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [charge_transport_ca]
    type = BulkChargeTransport
    electrical_energy_density = q_ca
    electric_potential = Phi_ca
    electric_conductivity = sigma_ca
    temperature = T
    block = cm
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
    output_properties = i
    outputs = exodus
  []
  [current_density_ca]
    type = CurrentDensity
    current_density = i_ca
    electric_potential = Phi_ca
    output_properties = i_ca
    outputs = exodus
    block = cm
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;a ${D_a} e ${D_e} cm ${D_cm} cp ${D_cp}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T_ref
    reference_concentration = ${c_ref_entropy}
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
    energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q q_ca zeta m&#x27;
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
    outputs = exodus
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_a}; 2.77e-4*x^2-0.0069*x+0.0785&#x27;
    # function = &#x27;x:=c/${cmax_a}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;a&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax_c}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cp&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;a_e&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;e_a&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cp_cm&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cm_cp&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
    output_properties = h
    outputs = exodus
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
    output_properties = r
    outputs = exodus
  []
  [conv]
    type = ADParsedMaterial
    f_name = qconv
    function = &#x27;${htc}*(T-T_ref)&#x27;
    args = &#x27;T T_ref&#x27;
    boundary = &#x27;left right&#x27;
  []

  # Mechanical
  [stiffness_cp]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cp*nu_cp/(1+nu_cp)/(1-2*nu_cp)} ${fparse E_cp/2/(1+nu_cp)}&#x27;
    block = cp
  []
  [stiffness_cm]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_cm*nu_cm/(1+nu_cm)/(1-2*nu_cm)} ${fparse E_cm/2/(1+nu_cm)}&#x27;
    block = cm
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = e
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = a
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
    non_swelling_pressure = p
    output_properties = &#x27;p&#x27;
    outputs = exodus
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi_ca
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_l - V_r&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_V]
    type = Terminator
    expression = &#x27;V &lt;= 2.5&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options = &#x27;-ksp_converged_reason&#x27;
  # petsc_options_iname = &#x27;-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor&#x27;
  # petsc_options_value = &#x27;hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4&#x27;
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  ignore_variables_for_autoscaling = &#x27;T&#x27;
  verbose = true
  line_search = none

  l_max_its = 300
  l_tol = 1e-6
  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-9
  nl_max_its = 12

  [Predictor]
    type = SimplePredictor
    scale = 1
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = &#x27;${fparse t0/50}&#x27;
    optimal_iterations = 6
    iteration_window = 1
    growth_factor = 1.2
    cutback_factor = 0.2
    cutback_factor_at_failure = 0.1
    linear_iteration_ratio = 100
  []
  end_time = 10000
[]

[Outputs]
  exodus = true
  csv = true
  print_linear_residuals = false
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="66eb3869-797e-4b7c-aaf0-80e2905bc400"><div class="modal-content"><h4>(examples/LiB/CV_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;

sigma_a = 1e0 #mS/mm
sigma_e = 1e-1 #mS/mm
sigma_c = 1e-2 #mS/mm

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmin = 1e-4 #mmol/mm^3
cmax = 1e-3 #mmol/mm^3
D_a = 1e-3 #mm^2/s
D_e = 1e-4 #mm^2/s
D_c = 5e-5 #mm^2/s

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_c = 1e5
E_e = 1e4
E_a = 2e5
nu_c = 0.3
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 60
beta = 1e-3
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s

T_penalty = 2e-1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q zeta m&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Problem]
  restart_file_base = &#x27;CC_charging_I_${I}_cp/LATEST&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = cathode
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
  [Phi0]
  []
[]

[ICs]
  [c_ref_min]
    type = ConstantIC
    variable = c_ref
    value = ${cmin}
    block = &#x27;anode&#x27;
  []
  [c_ref_mid]
    type = ConstantIC
    variable = c_ref
    value = &#x27;${fparse (cmax+cmin)/2}&#x27;
    block = &#x27;elyte&#x27;
  []
  [c_ref_max]
    type = ConstantIC
    variable = c_ref
    value = ${cmax}
    block = &#x27;cathode&#x27;
  []
[]

[AuxKernels]
  [Phi0]
    type = ParsedAux
    variable = Phi0
    function = &#x27;Phi&#x27;
    args = &#x27;Phi&#x27;
    execute_on = &#x27;INITIAL&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;elyte_anode cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;anode_elyte elyte_cathode elyte_anode cathode_elyte&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [Phi]
    type = CoupledVarDirichletBC
    variable = Phi
    boundary = &#x27;left right&#x27;
    value = Phi0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
[]

[Constraints]
  [y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;anode ${D_a} elyte ${D_e} cathode ${D_c}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Redox
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)&#x27;
    args = c
    block = &#x27;anode&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)&#x27;
    args = c
    block = &#x27;cathode&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_anode&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_cathode&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []

  # Mechanical
  [stiffness_c]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_c*nu_c/(1+nu_c)/(1-2*nu_c)} ${fparse E_c/2/(1+nu_c)}&#x27;
    block = cathode
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = elyte
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = anode
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_i]
    type = Terminator
    expression = &#x27;-I &lt;= 1e-6&#x27;
    message = &#x27;No current.&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  start_time = 0
  end_time = 100000

  steady_state_start_time = 10
  steady_state_detection = true
[]

[Outputs]
  file_base = &#x27;CV_charging_I_${I}&#x27;
  csv = true
  exodus = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="21a00a61-23e1-4101-a9a5-504d749fc3ce"><div class="modal-content"><h4>(test/tests/electrical-thermal/jh.i)</h4><pre class="moose-pre"><code class="language-text">n = 32

[GlobalParams]
  energy_densities = &#x27;E H&#x27;
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 1
    xmin = 0
    xmax = 1
    nx = ${n}
  []
[]

[Variables]
  [Phi]
  []
  [T]
  []
[]

[Functions]
  [Phi]
    type = ParsedFunction
    expression = &#x27;3.565*exp(x)-4.71*x^2+7.1*x-3.4&#x27;
  []
  [sigma]
    type = ParsedFunction
    expression = &#x27;1+x&#x27;
  []
  [q]
    type = ParsedFunction
    expression = &#x27;2.32+exp(x)*(-7.13-3.565*x)+18.84*x&#x27;
  []
  [kappa]
    type = ParsedFunction
    expression = &#x27;-2.6*x+3&#x27;
  []
[]

[Kernels]
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  [charge]
    type = BodyForce
    variable = Phi
    function = q
  []
  [energy_balance_1]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [energy_balance_2]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[BCs]
  [fix]
    type = FunctionDirichletBC
    variable = Phi
    boundary = &#x27;left right&#x27;
    function = Phi
  []
  [hconv]
    type = ADMatNeumannBC
    variable = T
    boundary = right
    value = -1
    boundary_material = qconv
  []
[]

[Materials]
  [electric_constants]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;sigma&#x27;
    prop_values = &#x27;sigma&#x27;
  []
  [charge_trasport]
    type = BulkChargeTransport
    electrical_energy_density = E
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []
  [thermal_constants]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;kappa&#x27;
    prop_values = &#x27;kappa&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = H
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []
  [qconv]
    type = ADParsedMaterial
    property_name = qconv
    expression = &#x27;htc*(T-T_inf)&#x27;
    coupled_variables = &#x27;T&#x27;
    constant_names = &#x27;htc T_inf&#x27;
    constant_expressions = &#x27;1.35 300&#x27;
    boundary = right
  []
[]

[Postprocessors]
  [error]
    type = ElementL2Error
    variable = Phi
    function = Phi
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true

  num_steps = 1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="970b64fe-5134-473d-acdd-2426841a6b63"><div class="modal-content"><h4>(examples/LiB/CC_charging.i)</h4><pre class="moose-pre"><code class="language-text">I = 3e-3 #mA
width = 0.03 #mm
in = &#x27;${fparse -I/width}&#x27;
t0 = &#x27;${fparse -1e-2/in}&#x27;
dt = &#x27;${fparse t0/100}&#x27;

sigma_a = 1e0 #mS/mm
sigma_e = 1e-1 #mS/mm
sigma_c = 1e-2 #mS/mm

l0 = 0
l1 = 0.04
l2 = 0.07
l3 = 0.12

cmin = 1e-4 #mmol/mm^3
cmax = 1e-3 #mmol/mm^3
D_a = 1e-3 #mm^2/s
D_e = 1e-4 #mm^2/s
D_c = 5e-5 #mm^2/s

R = 8.3145 #mJ/mmol/K
T0 = 300 #K
F = 96485 #mC/mmol

i0_a = 1e-1 #mA/mm^2
i0_c = 1e-1 #mA/mm^2

E_c = 1e5
E_e = 1e4
E_a = 2e5
nu_c = 0.3
nu_e = 0.25
nu_a = 0.3

u_penalty = 1e8

Omega = 60
beta = 1e-3
CTE = 1e-5

rho = 2.5e-9 #Mg/mm^3
cv = 2.7e8 #mJ/Mg/K
kappa = 2e-4 #mJ/mm/K/s

T_penalty = 2e-1

[GlobalParams]
  energy_densities = &#x27;dot(psi_m) dot(psi_c) chi q zeta m&#x27;
  deformation_gradient = F
  mechanical_deformation_gradient = Fm
  eigen_deformation_gradient = Fg
  swelling_deformation_gradient = Fs
  thermal_deformation_gradient = Ft
[]

[Mesh]
  [battery]
    type = GeneratedMeshGenerator
    dim = 2
    xmin = ${l0}
    xmax = ${l3}
    ymin = 0
    ymax = ${width}
    nx = 60
    ny = 15
  []
  [anode]
    type = SubdomainBoundingBoxGenerator
    input = battery
    block_id = 1
    block_name = anode
    bottom_left = &#x27;${l0} 0 0&#x27;
    top_right = &#x27;${l1} ${width} 0&#x27;
  []
  [elyte]
    type = SubdomainBoundingBoxGenerator
    input = anode
    block_id = 2
    block_name = elyte
    bottom_left = &#x27;${l1} 0 0&#x27;
    top_right = &#x27;${l2} ${width} 0&#x27;
  []
  [cathode]
    type = SubdomainBoundingBoxGenerator
    input = elyte
    block_id = 3
    block_name = cathode
    bottom_left = &#x27;${l2} 0 0&#x27;
    top_right = &#x27;${l3} ${width} 0&#x27;
  []
  [interfaces]
    type = BreakMeshByBlockGenerator
    input = cathode
    add_interface_on_two_sides = true
    split_interface = true
  []
[]

[Variables]
  [Phi]
  []
  [c]
  []
  [disp_x]
  []
  [disp_y]
  []
  [T]
    initial_condition = ${T0}
  []
[]

[AuxVariables]
  [c_ref]
  []
  [T_ref]
    initial_condition = ${T0}
  []
[]

[ICs]
  [c_min]
    type = ConstantIC
    variable = c
    value = ${cmin}
    block = &#x27;anode&#x27;
  []
  [c_mid]
    type = ConstantIC
    variable = c
    value = &#x27;${fparse (cmax+cmin)/2}&#x27;
    block = &#x27;elyte&#x27;
  []
  [c_max]
    type = ConstantIC
    variable = c
    value = ${cmax}
    block = &#x27;cathode&#x27;
  []
  [c_ref_min]
    type = ConstantIC
    variable = c_ref
    value = ${cmin}
    block = &#x27;anode&#x27;
  []
  [c_ref_mid]
    type = ConstantIC
    variable = c_ref
    value = &#x27;${fparse (cmax+cmin)/2}&#x27;
    block = &#x27;elyte&#x27;
  []
  [c_ref_max]
    type = ConstantIC
    variable = c_ref
    value = ${cmax}
    block = &#x27;cathode&#x27;
  []
[]

[Kernels]
  # Charge balance
  [charge_balance]
    type = RankOneDivergence
    variable = Phi
    vector = i
  []
  # Mass balance
  [mass_balance_1]
    type = TimeDerivative
    variable = c
  []
  [mass_balance_2]
    type = RankOneDivergence
    variable = c
    vector = j
  []
  # Momentum balance
  [momentum_balance_x]
    type = RankTwoDivergence
    variable = disp_x
    component = 0
    tensor = pk1
    factor = -1
  []
  [momentum_balance_y]
    type = RankTwoDivergence
    variable = disp_y
    component = 1
    tensor = pk1
    factor = -1
  []
  # Energy balance
  [energy_balance_1]
    type = EnergyBalanceTimeDerivative
    variable = T
    density = rho
    specific_heat = cv
  []
  [energy_balance_2]
    type = RankOneDivergence
    variable = T
    vector = h
  []
  [heat_source]
    type = MaterialSource
    variable = T
    prop = r
    coefficient = -1
  []
[]

[InterfaceKernels]
  [negative_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    factor = -1
    boundary = &#x27;elyte_anode cathode_elyte&#x27;
  []
  [positive_current]
    type = MaterialInterfaceNeumannBC
    variable = Phi
    neighbor_var = Phi
    prop = ie
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [heat]
    type = MaterialInterfaceNeumannBC
    variable = T
    neighbor_var = T
    prop = he
    factor = 1
    boundary = &#x27;anode_elyte elyte_cathode elyte_anode cathode_elyte&#x27;
  []
  [continuity_disp_x]
    type = InterfaceContinuity
    variable = disp_x
    neighbor_var = disp_x
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_disp_y]
    type = InterfaceContinuity
    variable = disp_y
    neighbor_var = disp_y
    penalty = ${u_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
  [continuity_T]
    type = InterfaceContinuity
    variable = T
    neighbor_var = T
    penalty = ${T_penalty}
    boundary = &#x27;anode_elyte elyte_cathode&#x27;
  []
[]

[Functions]
  [in]
    type = PiecewiseLinear
    x = &#x27;0 ${t0}&#x27;
    y = &#x27;0 ${in}&#x27;
  []
[]

[BCs]
  [left]
    type = FunctionNeumannBC
    variable = Phi
    boundary = left
    function = in
  []
  [right]
    type = DirichletBC
    variable = Phi
    boundary = right
    value = 0
  []
  [fix_x]
    type = DirichletBC
    variable = disp_x
    value = 0
    boundary = &#x27;left right&#x27;
  []
  [fix_y]
    type = DirichletBC
    variable = disp_y
    value = 0
    boundary = &#x27;bottom&#x27;
  []
  [open]
    type = OpenBC
    variable = c
    flux = jm
    boundary = &#x27;left right&#x27;
  []
[]

[Constraints]
  [y]
    type = EqualValueBoundaryConstraint
    variable = disp_y
    penalty = ${u_penalty}
    secondary = top
  []
[]

[Materials]
  # Electrodynamics
  [conductivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;sigma&#x27;
    subdomain_to_prop_value = &#x27;anode ${sigma_a} elyte ${sigma_e} cathode ${sigma_c}&#x27;
  []
  [charge_transport]
    type = BulkChargeTransport
    electrical_energy_density = q
    electric_potential = Phi
    electric_conductivity = sigma
    temperature = T
  []
  [current_density]
    type = CurrentDensity
    current_density = i
    electric_potential = Phi
  []

  # Chemical reactions
  [diffusivity]
    type = ADPiecewiseConstantByBlockMaterial
    prop_name = &#x27;D&#x27;
    subdomain_to_prop_value = &#x27;anode ${D_a} elyte ${D_e} cathode ${D_c}&#x27;
  []
  [mobility]
    type = ADParsedMaterial
    f_name = M
    args = &#x27;c_ref T_ref&#x27;
    material_property_names = &#x27;D&#x27;
    function = &#x27;D*c_ref/${R}/T_ref&#x27;
  []
  [chemical_energy]
    type = EntropicChemicalEnergyDensity
    chemical_energy_density = psi_c
    concentration = c
    ideal_gas_constant = ${R}
    temperature = T
    reference_concentration = c_ref
  []
  [chemical_potential]
    type = ChemicalPotential
    chemical_potential = mu
    concentration = c
  []
  [diffusion]
    type = MassDiffusion
    dual_chemical_energy_density = zeta
    chemical_potential = mu
    mobility = M
  []
  [mass_flux]
    type = MassFlux
    mass_flux = j
    chemical_potential = mu
  []

  # Migration
  [migration]
    type = Migration
    electrochemical_energy_density = m
    electric_potential = Phi
    chemical_potential = mu
    electric_conductivity = sigma
    faraday_constant = ${F}
  []
  [migration_flux]
    type = MassFlux
    mass_flux = jm
    energy_densities = &#x27;m&#x27;
    chemical_potential = mu
  []

  # Redox
  [ramp]
    type = ADGenericFunctionMaterial
    prop_names = &#x27;ramp&#x27;
    prop_values = &#x27;if(t&lt;${t0},t/${t0},1)&#x27;
  []
  [OCP_anode_graphite]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; -(122.12*x^6-321.81*x^5+315.59*x^4-141.26*x^3+28.218*x^2-1.9057*x+0.0785)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;anode&#x27;
  []
  [OCP_cathode_NMC111]
    type = ADParsedMaterial
    f_name = U
    function = &#x27;x:=c/${cmax}; (6.0826-6.9922*x+7.1062*x^2-5.4549e-5*exp(124.23*x-114.2593)-2.5947*x^3)*ramp&#x27;
    args = c
    material_property_names = &#x27;ramp&#x27;
    block = &#x27;cathode&#x27;
  []
  [charge_transfer_anode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;anode_elyte&#x27;
  []
  [charge_transfer_elyte_anode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_a}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_anode&#x27;
  []
  [charge_transfer_cathode_elyte]
    type = ChargeTransferReaction
    electrode = true
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;cathode_elyte&#x27;
  []
  [charge_transfer_elyte_cathode]
    type = ChargeTransferReaction
    electrode = false
    charge_transfer_current_density = ie
    charge_transfer_mass_flux = je
    charge_transfer_heat_flux = he
    electric_potential = Phi
    neighbor_electric_potential = Phi
    charge_transfer_coefficient = 0.5
    exchange_current_density = ${i0_c}
    faraday_constant = ${F}
    ideal_gas_constant = ${R}
    temperature = T
    open_circuit_potential = U
    boundary = &#x27;elyte_cathode&#x27;
  []

  # Thermal
  [thermal_properties]
    type = ADGenericConstantMaterial
    prop_names = &#x27;rho cv kappa&#x27;
    prop_values = &#x27;${rho} ${cv} ${kappa}&#x27;
  []
  [heat_conduction]
    type = FourierPotential
    thermal_energy_density = chi
    thermal_conductivity = kappa
    temperature = T
  []
  [heat_flux]
    type = HeatFlux
    heat_flux = h
    temperature = T
  []
  [heat_source]
    type = VariationalHeatSource
    heat_source = r
    temperature = T
  []

  # Mechanical
  [stiffness_c]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_c*nu_c/(1+nu_c)/(1-2*nu_c)} ${fparse E_c/2/(1+nu_c)}&#x27;
    block = cathode
  []
  [stiffness_e]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_e*nu_e/(1+nu_e)/(1-2*nu_e)} ${fparse E_e/2/(1+nu_e)}&#x27;
    block = elyte
  []
  [stiffness_a]
    type = ADGenericConstantMaterial
    prop_names = &#x27;lambda G&#x27;
    prop_values = &#x27;${fparse E_a*nu_a/(1+nu_a)/(1-2*nu_a)} ${fparse E_a/2/(1+nu_a)}&#x27;
    block = anode
  []
  [swelling_coefficient]
    type = ADGenericConstantMaterial
    prop_names = &#x27;beta&#x27;
    prop_values = &#x27;${beta}&#x27;
  []
  [swelling]
    type = SwellingDeformationGradient
    concentration = c
    reference_concentration = c_ref
    molar_volume = ${Omega}
    swelling_coefficient = beta
  []
  [thermal_expansion]
    type = ThermalDeformationGradient
    temperature = T
    reference_temperature = T_ref
    CTE = ${CTE}
  []
  [defgrad]
    type = MechanicalDeformationGradient
    displacements = &#x27;disp_x disp_y&#x27;
  []
  [neohookean]
    type = NeoHookeanSolid
    elastic_energy_density = psi_m
    lambda = lambda
    shear_modulus = G
    concentration = c
    temperature = T
  []
  [pk1]
    type = FirstPiolaKirchhoffStress
    first_piola_kirchhoff_stress = pk1
    deformation_gradient_rate = dot(F)
  []
[]

[Postprocessors]
  [V_l]
    type = SideAverageValue
    variable = Phi
    boundary = left
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V_r]
    type = SideAverageValue
    variable = Phi
    boundary = right
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [V]
    type = ParsedPostprocessor
    function = &#x27;V_r - V_l&#x27;
    pp_names = &#x27;V_l V_r&#x27;
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [I]
    type = ADSideIntegralMaterialProperty
    property = i
    component = 0
    boundary = right
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dt]
    type = TimestepSize
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [dC]
    type = ParsedPostprocessor
    function = &#x27;-dt*I&#x27;
    pp_names = &#x27;dt I&#x27;
    outputs = none
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [C]
    type = CumulativeValuePostprocessor
    postprocessor = dC
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_a_min]
    type = NodalExtremeValue
    variable = c
    value_type = min
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [c_c_max]
    type = NodalExtremeValue
    variable = c
    value_type = max
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_a]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = anode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_e]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = elyte
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
  [mass_c]
    type = ElementIntegralVariablePostprocessor
    variable = c
    block = cathode
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  []
[]

[UserObjects]
  [kill_a]
    type = Terminator
    expression = &#x27;c_a_max &gt;= ${cmax}&#x27;
    message = &#x27;Concentration in anode exceeds the maximum allowable value.&#x27;
  []
  [kill_c]
    type = Terminator
    expression = &#x27;c_c_min &lt;= ${cmin}&#x27;
    message = &#x27;Concentration in cathode is below the minimum allowable value.&#x27;
  []
[]

[Executioner]
  type = Transient
  solve_type = NEWTON

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  automatic_scaling = true
  line_search = none

  nl_rel_tol = 1e-6
  nl_abs_tol = 1e-10
  nl_max_its = 20

  [Predictor]
    type = SimplePredictor
    scale = 1
    skip_after_failed_timestep = true
  []
  [TimeStepper]
    type = IterationAdaptiveDT
    dt = ${dt}
    optimal_iterations = 7
    iteration_window = 2
    growth_factor = 1.2
    cutback_factor = 0.5
    cutback_factor_at_failure = 0.2
    linear_iteration_ratio = 1000000
  []
  end_time = 100000
[]

[Outputs]
  file_base = &#x27;CC_charging_I_${I}&#x27;
  csv = true
  exodus = true
  print_linear_residuals = false
  checkpoint = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#40952c63-7002-4707-803e-2c2d5c9d5f93" class="tooltipped" data-position="left" data-tooltip="Overview">Overview</a></li><li><a href="#2020a856-a6fe-4c73-8caa-859a889c620a" class="tooltipped" data-position="left" data-tooltip="Example Input File Syntax">Example Input File Syntax</a></li><li><a href="#520b0031-69f8-4456-90f5-e4e6ed3f69fe" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#0546137b-4775-45ea-8d7d-310bbd6626d0" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../../js/init.js"></script><script type="text/javascript" src="../../../js/navigation.js"></script><script type="text/javascript" src="../../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../../js/search_index.js"></script><script type="text/javascript" src="../../../js/sqa_moose.js"></script>